The file `src/clj/game/macros.clj` has three important macro definitions. A Clojure macro is like a function that executes during the compilation of the program, which has the effect of modifying the code of the program itself. When a macro is applied to a form, the macro applies transformations to that form to have some effect on the generated code. We use four macros when coding card behaviors in Jinteki.net: `effect`, `req`, `msg`, and `when-completed`.

### Five-argument functions

Card effects and events generally need five values in order to apply their effects: the current `state` of the game; the `side` of the player that triggered the card ability or game event; an `eid` (effect ID) that gives a unique number to the effect that is being resolved; the data of the `card` that is responding to that action or event; and a sequence of `targets` affected by the ability or event, specific to that action. AstroScript Pilot Program, for example, when clicked needs to know the data of the actual AstroScript `card` that was clicked, to make sure it has a token; the `side` of the player that clicked it, to ensure the Corp is taking the action; and a sequence containing the card targeted by the click action. This pattern occurs so frequently that we use macros to simplify the process of defining a function that takes five arguments, `state side eid card targets`. This ensures that all card and engine abilities can access the full game state, the state of the individual card in question, a unique identifier for the effect, the side of the acting player, and a sequence of targets when resolving the ability. Not all of these are needed for every ability, but for consistency the engine will always pass them, and so a receiving function must have 5 arguments to bind correctly.

Each of the macros `effect`, `req`, and `msg` define a five-argument function taking the arguments `[state side eid card targets]`. We wrap a series of function calls inside one of the macros to define the body of the anonymous five-argument function it defines. The differences between the three are subtle but important:

* `effect` will take each function call inside the macro and insert `state` and `side` as the first two arguments to the called function. Thus, `(effect (draw 1))` becomes `(draw state side 1)`, inheriting the same state and side passed to the anonymous function. (This is important.) If you don't want to reuse the same `side` that you get, you can pass a new side as the first argument to the called function: `(effect (draw :runner 1))` forces the draw for the Runner, even if the effect is being triggered on a Corp card.

    `effect` defines a few helper bindings to make your life easier. `runner` and `corp` bind to `(:runner @state)` and `(:corp @state)` respectively, granting access to runner or corp data. `corp-reg` and `runner-reg` give the "register" (notes that are cleared at end of turn) for the players. `current-ice` gives the ice being encountered in the current run, or `nil` if there is no run. `target` is `(first targets)` -- the first of the targets sequence is often important enough to get its own immediate binding.

* `req` does not insert `state` and `side` the way `effect` does. That's the big difference. Otherwise it adds a few more bindings: `run` is the state of the current run (__IMPORTANT__: this means you must scope `(game.core/run ...)` if you want to trigger a run from a `req`). `remotes` gets a sequence of names of the in-use remote servers. `runnable-servers` gets a filtered list of servers that can be run on (Replicating Perfection, Off the Grid). `tagged` is true if the runner has a tag or is permanently tagged (Paparazzi). `this-server` is true if the runner is currently running on the same server that the current `card` is installed in or protecting.

* `msg` defines a five-argument function that has many of the same bindings as `req`, but calls `str` on its contents upon execution. 